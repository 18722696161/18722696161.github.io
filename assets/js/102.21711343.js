(window.webpackJsonp=window.webpackJsonp||[]).push([[102],{317:function(t,e,n){"use strict";n.r(e);var a=n(5),s=Object(a.a)({},(function(){var t=this,e=t._self._c;return e("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[e("h1",{attrs:{id:"插槽slot"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#插槽slot"}},[t._v("#")]),t._v(" 插槽slot")]),t._v(" "),e("h2",{attrs:{id:"分类"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#分类"}},[t._v("#")]),t._v(" 分类")]),t._v(" "),e("p",[t._v("Vue中的插槽有三种类型：默认插槽和具名插槽以及作用域。下面我将为您详细介绍它们及代码演示。")]),t._v(" "),e("h2",{attrs:{id:"默认插槽"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#默认插槽"}},[t._v("#")]),t._v(" 默认插槽")]),t._v(" "),e("p",[t._v("默认插槽是指没有指定名称的插槽，只需在子组件中使用"),t._t("default"),t._v("标签即可定义默认插槽。父组件在使用子组件时可以向默认插槽传递内容。")],2),t._v(" "),e("p",[t._v("下面是一个使用默认插槽的示例：")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("\x3c!-- 子组件 --\x3e\n<template>\n  <div>\n    <h3>子组件</h3>\n    <slot></slot>\n  </div>\n</template>\n\n\x3c!-- 父组件 --\x3e\n<template>\n  <div>\n    <h2>父组件</h2>\n    <child-component>\n      <p>这是默认插槽的内容</p>\n    </child-component>\n  </div>\n</template>\n")])])]),e("p",[t._v("在上面的代码中，子组件中定义了一个默认插槽，并将其放在slot标签中。父组件中使用child-component标签引入子组件，并在标签内部传递了一个p标签作为默认插槽的内容。在渲染时，slot标签会被替换为父组件传递的内容。")]),t._v(" "),e("h2",{attrs:{id:"具名插槽"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#具名插槽"}},[t._v("#")]),t._v(" 具名插槽")]),t._v(" "),e("p",[t._v("具名插槽是指在子组件中使用名称来定义的插槽，它允许父组件在使用子组件时向具名插槽传递内容。要定义具名插槽，可以在slot标签上使用name属性，如下所示：")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v('\x3c!-- 子组件 --\x3e\n<template>\n  <div>\n    <h3>子组件</h3>\n    <slot name="header"></slot>\n    <slot name="content"></slot>\n  </div>\n</template>\n\n\x3c!-- 父组件 --\x3e\n<template>\n  <div>\n    <h2>父组件</h2>\n    <child-component>\n      <h4 slot="header">这是标题</h4>\n      <p slot="content">这是内容</p>\n    </child-component>\n  </div>\n</template>\n在上面的代码中，子组件中定义了两个具名插槽，分别是<slot name="header"></slot>和<slot name="content"></slot>。在父组件中，通过在<h4>标签上使用slot="header"和在<p>标签上使用slot="content"，将内容传递给了子组件中对应的插槽。在渲染时，具名插槽会被替换为父组件传递的内容。\n')])])]),e("h2",{attrs:{id:"作用域插槽"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#作用域插槽"}},[t._v("#")]),t._v(" 作用域插槽")]),t._v(" "),e("p",[t._v("作用域插槽是一种特殊的插槽，它允许父组件将数据传递到子组件中，并在子组件中渲染这些数据。通常情况下，子组件会在插槽内部使用slot-scope属性来定义作用域，以便在子组件中使用父组件传递的数据。")]),t._v(" "),e("p",[t._v("下面是一个使用作用域插槽的示例：")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v('\x3c!-- 子组件 --\x3e\n<template>\n  <div>\n    <h3>子组件</h3>\n    <ul>\n      <li v-for="item in items" :key="item.id">\n        <slot :item="item"></slot>\n      </li>\n    </ul>\n  </div>\n</template>\n\n\x3c!-- 父组件 --\x3e\n<template>\n  <div>\n    <h2>父组件</h2>\n    <child-component>\n      <template slot-scope="props">\n        <span>{{ props.item.id }}</span>\n        <span>{{ props.item.name }}</span>\n      </template>\n    </child-component>\n  </div>\n</template>\n')])])]),e("p",[t._v('在上面的代码中，子组件中定义了一个具名插槽，并在slot标签中使用:item="item"的方式向父组件传递数据。在父组件中，通过在template标签上使用slot-scope="props"，将子组件传递过来的数据挂载到props对象上。在template标签内部，我们可以通过props对象来访问传递的数据，这里我们使用了props.item.id和props.item.name来渲染列表项的内容。')])])}),[],!1,null,null,null);e.default=s.exports}}]);