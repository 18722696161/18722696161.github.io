(window.webpackJsonp=window.webpackJsonp||[]).push([[63],{303:function(n,e,l){"use strict";l.r(e);var a=l(5),t=Object(a.a)({},(function(){var n=this,e=n._self._c;return e("ContentSlotsDistributor",{attrs:{"slot-key":n.$parent.slotKey}},[e("h1",{attrs:{id:"继承"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#继承"}},[n._v("#")]),n._v(" 继承")]),n._v(" "),e("h2",{attrs:{id:"继承的几种方式以及优缺点"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#继承的几种方式以及优缺点"}},[n._v("#")]),n._v(" 继承的几种方式以及优缺点")]),n._v(" "),e("h3",{attrs:{id:"原型链继承"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#原型链继承"}},[n._v("#")]),n._v(" 原型链继承")]),n._v(" "),e("p",[n._v("原型链继承是 JavaScript 中最常用的继承方式之一，它的核心是通过将一个对象的原型指向另一个对象来实现继承。子类的实例可以访问父类的方法和属性。\n代码如下：")]),n._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[n._v("function Parent() {\n  this.name = 'Parent';\n}\n\nParent.prototype.sayHello = function() {\n  console.log('Hello, I am ' + this.name);\n};\n\nfunction Child() {\n  this.name = 'Child';\n}\n\nChild.prototype = new Parent();\n\nvar child = new Child();\nchild.sayHello(); // 输出 \"Hello, I am Child\"\n\n")])])]),e("p",[n._v("优点：")]),n._v(" "),e("p",[n._v("父类的方法和属性可以被子类共享。\n可以实现多级继承。")]),n._v(" "),e("p",[n._v("缺点：")]),n._v(" "),e("p",[n._v("如果父类的原型中包含引用类型的属性，子类实例会共享这些属性，可能会造成不必要的麻烦。\n无法向父类传递参数。")]),n._v(" "),e("ol",[e("li",[n._v("父类的方法和属性可以被子类共享：")])]),n._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[n._v('function Parent() {\n  this.colors = ["red", "blue", "green"];\n}\n\nfunction Child() {}\n\nChild.prototype = new Parent();\n\nvar child1 = new Child();\nchild1.colors.push("black");\n\nvar child2 = new Child();\n\nconsole.log(child1.colors); // 输出 ["red", "blue", "green", "black"]\nconsole.log(child2.colors); // 输出 ["red", "blue", "green", "black"]\n')])])]),e("p",[n._v('在上述代码中，我们定义了一个父类 Parent 和一个子类 Child。子类 Child 的原型对象是父类 Parent 的实例。然后我们创建了两个子类实例 child1 和 child2，并向 child1 实例的 colors 属性中添加了一个新元素。接着我们分别输出了 child1.colors 和 child2.colors，发现它们的值都是 ["red", "blue", "green", "black"]。这是因为 child1 和 child2 共享同一个原型对象，而 child1 向 colors 属性中添加了一个新元素，所以 child2 的 colors 属性也受到了影响。这种行为可能会导致意外的副作用和错误。')]),n._v(" "),e("ol",{attrs:{start:"2"}},[e("li",[n._v("无法向父类传递参数：")])]),n._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[n._v("function Parent(name) {\n  this.name = name;\n}\n\nParent.prototype.sayHello = function() {\n  console.log('Hello, I am ' + this.name);\n};\n\nfunction Child() {}\n\nChild.prototype = new Parent('Parent');\n\nvar child = new Child();\nchild.sayHello(); // 输出 \"Hello, I am Parent\"\n")])])]),e("p",[n._v("在上述代码中，我们在创建 Child 的原型对象时，使用 new Parent('Parent') 来创建了一个 Parent 的实例，并将其赋值给了 Child 的原型对象。这样，Child 的原型对象就继承了 Parent 的属性和方法，包括 name 属性和 sayHello 方法。但是，由于我们使用 new Parent('Parent') 来创建 Parent 的实例，这个实例已经在 Parent 的构造函数中被初始化了，并且传递了参数 'Parent'，无法再向构造函数中传递其他参数。因此，在上述代码中，我们无法向 Parent 传递其他参数。")]),n._v(" "),e("h3",{attrs:{id:"构造函数继承"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#构造函数继承"}},[n._v("#")]),n._v(" 构造函数继承")]),n._v(" "),e("p",[n._v("构造函数继承是通过在子类构造函数中调用父类构造函数来实现继承的。通过使用 call 或 apply 方法，可以将父类构造函数的作用域赋给子类，使子类获得父类构造函数中的属性和方法。")]),n._v(" "),e("p",[n._v("代码如下：")]),n._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[n._v("function Parent(name) {\n  this.name = name || 'Parent';\n}\n\nParent.prototype.sayHello = function() {\n  console.log('Hello, I am ' + this.name);\n};\n\nfunction Child(name) {\n  Parent.call(this, name || 'Child');\n}\n\nvar child = new Child();\nchild.sayHello(); // TypeError: child.sayHello is not a function\n")])])]),e("p",[n._v("优点：")]),n._v(" "),e("p",[n._v("可以向父类传递参数。\n父类的属性和方法不会被子类实例共享。")]),n._v(" "),e("p",[n._v("缺点：")]),n._v(" "),e("p",[n._v("无法继承父类原型上的属性和方法。\n每个子类实例都会创建一个父类实例的副本，可能会造成不必要的内存浪费。")]),n._v(" "),e("ol",[e("li",[n._v("无法继承父类原型上的属性和方法：\n构造函数继承无法继承父类原型上的属性和方法的原因是因为在使用构造函数继承时，只是在子类构造函数内部调用了父类构造函数，并没有实际上将父类的原型对象赋值给子类的原型对象。因此，子类的原型对象并没有继承父类原型对象上的属性和方法。")])]),n._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[n._v("function Parent(name) {\n  this.name = name;\n}\n\nParent.prototype.sayHello = function() {\n  console.log('Hello, I am ' + this.name);\n};\n\nfunction Child(name) {\n  Parent.call(this, name);\n}\n\nvar child = new Child('Child');\nchild.sayHello(); // TypeError: child.sayHello is not a function\n")])])]),e("p",[n._v("在上述代码中，我们定义了一个 Parent 构造函数，并在它的原型对象上增加了一个 sayHello 方法。然后，我们定义了一个 Child 构造函数，并在它的构造函数内部调用了 Parent 构造函数。这样，Child 对象就继承了 Parent 对象的属性和方法。但是，由于我们没有将 Parent 的原型对象赋值给 Child 的原型对象，因此 Child 对象无法继承 Parent 的原型对象上的属性和方法，例如上述代码中的 sayHello 方法。因此，当我们在 child 对象上调用 sayHello 方法时，会抛出一个 TypeError 错误。")]),n._v(" "),e("ol",{attrs:{start:"2"}},[e("li",[n._v("每个子类实例都会创建一个父类实例的副本，可能会造成不必要的内存浪费。\n构造函数继承中，每个子类实例都会创建一个父类实例的副本的原因是因为在子类构造函数内部调用了父类构造函数，并使用 call 或 apply 方法将父类构造函数中的 this 指向子类实例。这样做的结果是，每次创建子类实例时都会创建一个新的父类实例，并将其作为子类实例的属性，这可能会造成不必要的内存浪费。")])]),n._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[n._v('function Parent(name) {\n  this.name = name;\n  this.colors = [\'red\', \'green\', \'blue\'];\n}\n\nfunction Child(name) {\n  Parent.call(this, name);\n}\n\nvar child1 = new Child(\'Child1\');\nvar child2 = new Child(\'Child2\');\n\nchild1.colors.push(\'yellow\');\nconsole.log(child1.colors); // ["red", "green", "blue", "yellow"]\nconsole.log(child2.colors); // ["red", "green", "blue"]\n')])])]),e("p",[n._v("在上述代码中，我们定义了一个 Parent 构造函数，并在其中定义了一个 colors 属性，它是一个数组。然后，我们定义了一个 Child 构造函数，并在其中调用了 Parent 构造函数。接着，我们创建了两个 Child 实例 child1 和 child2。然后，我们在 child1 实例上修改了 colors 数组，并发现 child2 实例并没有受到影响。这是因为每个 Child 实例都会创建一个新的 Parent 实例，因此它们之间不会共享父类的属性和方法，可能会造成不必要的内存浪费。")]),n._v(" "),e("h3",{attrs:{id:"组合继承"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#组合继承"}},[n._v("#")]),n._v(" 组合继承")]),n._v(" "),e("p",[n._v("组合继承是同时使用原型链继承和构造函数继承的一种方式。通过将父类构造函数的属性和方法赋给子类实例，再将父类的原型赋给子类原型，可以实现既可以访问父类原型上的属性和方法，又可以向父类传递参数。")]),n._v(" "),e("p",[n._v("代码如下：")]),n._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[n._v("function Parent(name) {\n  this.name = name || 'Parent';\n}\n\nParent.prototype.sayHello = function() {\n  console.log('Hello, I am ' + this.name);\n};\n\nfunction Child(name) {\n  Parent.call(this, name || 'Child');\n}\n\nChild.prototype = new Parent();\nChild.prototype.constructor = Child;\n\nvar child = new Child();\nchild.sayHello(); // 输出 \"Hello, I am Child\"\n")])])]),e("p",[n._v("优点：")]),n._v(" "),e("p",[n._v("既可以继承父类原型上的属性和方法，又可以向父类传递参数。\n每个子类实例都有自己的父类实例，不会共享属性和方法。")]),n._v(" "),e("p",[n._v("缺点：")]),n._v(" "),e("p",[n._v("父类构造函数的属性和方法会被子类实例重复创建。")]),n._v(" "),e("ol",[e("li",[n._v("父类构造函数的属性和方法会被子类实例重复创建。\n在组合继承中，因为子类构造函数中会调用父类构造函数，所以父类构造函数中定义的属性和方法会在子类构造函数中被调用并创建一份副本。同时，因为子类的原型也是指向了一个父类实例，所以父类原型中的属性和方法也被继承到了子类原型中。")])]),n._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[n._v("function Parent(name) {\n  this.name = name;\n}\n\nParent.prototype.sayHello = function() {\n  console.log('Hello, I am ' + this.name);\n};\n\nfunction Child(name, age) {\n  Parent.call(this, name);\n  this.age = age;\n}\n\nChild.prototype = new Parent();\nChild.prototype.constructor = Child;\n\nvar child1 = new Child('Tom', 10);\nvar child2 = new Child('Jerry', 12);\n\nconsole.log(child1.sayHello === child2.sayHello); // false\n")])])]),e("p",[n._v("在上面的示例中，我们定义了一个 Parent 构造函数和一个 Child 构造函数，并在 Child 构造函数中调用了 Parent 构造函数，实现了对父类构造函数的继承。然后将 Child 的原型指向一个 Parent 的实例，实现对父类原型的继承。最后创建了两个 Child 的实例，并比较了它们的 sayHello 方法是否相等。由于每个实例都会创建一份副本，因此比较结果为 false。")]),n._v(" "),e("p",[n._v("为了解决这个问题，可以使用 ES6 中的 class 语法糖，它可以更简洁地实现继承，而且不会出现父类构造函数属性和方法重复创建的问题。")]),n._v(" "),e("h3",{attrs:{id:"原型式继承"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#原型式继承"}},[n._v("#")]),n._v(" 原型式继承")]),n._v(" "),e("p",[n._v("原型式继承是通过创建一个临时构造函数来实现继承的。通过将父类的原型对象赋给临时构造函数的原型，然后返回一个新的实例对象，可以实现继承。")]),n._v(" "),e("p",[n._v("代码如下：")]),n._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[n._v("function createObj(o) {\n  function F() {}\n  F.prototype = o;\n  return new F();\n}\n\nvar parent = {\n  name: 'Parent',\n  sayHello: function() {\n    console.log('Hello, I am ' + this.name);\n  }\n};\n\nvar child = createObj(parent);\nchild.name = 'Child';\nchild.sayHello(); // 输出 \"Hello, I am Child\"\n")])])]),e("p",[n._v("优点：")]),n._v(" "),e("p",[n._v("可以方便地实现对象之间的继承关系。")]),n._v(" "),e("p",[n._v("缺点：")]),n._v(" "),e("p",[n._v("父类的引用类型属性会被所有子类实例共享。\n无法向父类传递参数。")]),n._v(" "),e("ol",[e("li",[n._v("父类的引用类型属性会被所有子类实例共享及无法向父类传递参数\n原型式继承是通过复制一个对象来实现继承的，其本质上是一种对现有对象的浅拷贝。具体而言，通过创建一个新的对象作为新的子类实例，并将该对象的原型指向一个现有的父类对象来实现继承。由于这个新对象的原型是父类对象，所以它能够访问到父类对象的所有属性和方法。但是，由于子类实例共享一个原型对象，因此父类的引用类型属性会被所有子类实例共享。")])]),n._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[n._v('var parent = {\n  name: \'Parent\',\n  colors: [\'red\', \'green\', \'blue\']\n};\n\nvar child1 = Object.create(parent);\nvar child2 = Object.create(parent);\n\nchild1.colors.push(\'yellow\');\nconsole.log(child1.colors); // ["red", "green", "blue", "yellow"]\nconsole.log(child2.colors); // ["red", "green", "blue", "yellow"]\n')])])]),e("p",[n._v("在上述代码中，我们创建了一个 parent 对象，它包含一个 colors 属性，是一个数组。然后，我们使用 Object.create 方法创建了两个新的对象 child1 和 child2，并将它们的原型都指向 parent 对象。接着，我们在 child1 对象上修改了 colors 数组，并发现 child2 对象也受到了影响，因为它们都共享了同一个 parent 对象。这是因为在原型式继承中，子类实例和父类对象之间的继承关系是通过原型链来实现的，因此所有子类实例都共享同一个原型对象，从而共享了父类的引用类型属性。")]),n._v(" "),e("p",[n._v("原型式继承也无法向父类传递参数，因为它是通过复制一个现有的对象来实现继承的，无法像构造函数继承那样向父类传递参数。")]),n._v(" "),e("h3",{attrs:{id:"寄生式继承"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#寄生式继承"}},[n._v("#")]),n._v(" 寄生式继承")]),n._v(" "),e("p",[n._v("寄生式继承是在原型式继承的基础上，增强了对象，即在原型式继承的基础上添加一些属性或方法，然后返回一个新的对象。")]),n._v(" "),e("p",[n._v("优点：")]),n._v(" "),e("p",[n._v("可以方便地实现对象之间的继承关系。\n可以增强对象，使得它们具有更多的功能。")]),n._v(" "),e("p",[n._v("缺点：")]),n._v(" "),e("p",[n._v("父类的引用类型属性会被所有子类实例共享。\n无法向父类传递参数。\n容易造成代码的混乱和不必要的复杂性。")]),n._v(" "),e("p",[n._v("代码如下：")]),n._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[n._v("function createObj(o) {\n  function F() {}\n  F.prototype = o;\n  return new F();\n}\n\nfunction createChild(parent) {\n  var child = createObj(parent);\n  child.name = 'Child';\n  child.sayHello = function() {\n    console.log('Hello, I am ' + this.name);\n  };\n  return child;\n}\n\nvar parent = {\n  name: 'Parent',\n  sayHello: function() {\n    console.log('Hello, I am ' + this.name);\n  }\n};\n\nvar child = createChild(parent);\nchild.sayHello(); // 输出 \"Hello, I am Child\"\n")])])]),e("p",[n._v("综上所述，不同的继承方式各有优缺点，我们可以根据具体的场景选择不同的继承方式。如果需要继承父类的原型属性和方法，可以使用原型链继承或组合继承；如果需要向父类传递参数，可以使用构造函数继承或组合继承；如果需要方便地实现对象之间的继承关系，可以使用原型式继承或寄生式继承。")])])}),[],!1,null,null,null);e.default=t.exports}}]);