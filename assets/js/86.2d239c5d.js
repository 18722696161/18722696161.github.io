(window.webpackJsonp=window.webpackJsonp||[]).push([[86],{369:function(e,t,s){"use strict";s.r(t);var a=s(5),r=Object(a.a)({},(function(){var e=this,t=e._self._c;return t("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[t("h1",{attrs:{id:"多页应用中如何运用vuex共享数据"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#多页应用中如何运用vuex共享数据"}},[e._v("#")]),e._v(" 多页应用中如何运用vuex共享数据")]),e._v(" "),t("p",[e._v("在多页面应用中，如果每个模块都是一个单页面应用，那么每个页面都会有自己的vuex实例，无法直接共享数据。不过，有几种方法可以解决这个问题：")]),e._v(" "),t("h2",{attrs:{id:"使用localstorage或sessionstorage"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#使用localstorage或sessionstorage"}},[e._v("#")]),e._v(" 使用localStorage或sessionStorage")]),e._v(" "),t("p",[e._v("可以将数据存储在localStorage或sessionStorage中，这样就可以在不同页面中共享数据。但是，需要注意的是，这种方法不适用于需要实时更新的数据，因为数据不会自动同步更新，需要手动更新。")]),e._v(" "),t("h2",{attrs:{id:"将vuex数据存储在服务端"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#将vuex数据存储在服务端"}},[e._v("#")]),e._v(" 将vuex数据存储在服务端")]),e._v(" "),t("p",[e._v("将vuex数据存储在服务端，每个模块都可以通过接口获取数据，实现数据共享。这种方法适用于大型应用，需要使用数据库和接口来实现数据存储和交互。")]),e._v(" "),t("h2",{attrs:{id:"使用iframe"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#使用iframe"}},[e._v("#")]),e._v(" 使用iframe")]),e._v(" "),t("p",[e._v("可以将每个模块放在一个iframe中，通过父页面来管理vuex数据，实现数据共享。这种方法需要考虑到跨域问题，需要设置好iframe的src和sandbox属性。")]),e._v(" "),t("h2",{attrs:{id:"使用vuex-persistedstate"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#使用vuex-persistedstate"}},[e._v("#")]),e._v(" 使用vuex-persistedstate")]),e._v(" "),t("p",[e._v("vuex-persistedstate是一个第三方库，可以将vuex数据存储在localStorage或sessionStorage中，实现数据共享。这个库会自动将vuex数据持久化到本地存储中，并且在页面刷新后可以自动恢复数据。")]),e._v(" "),t("p",[e._v("以上的方式中使用vuex-persistedstate是最为有效的方式，接下来我们具体来说明一下使用vuex-persistedstate的用法")]),e._v(" "),t("h3",{attrs:{id:"vuex-persistedstate用法"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#vuex-persistedstate用法"}},[e._v("#")]),e._v(" vuex-persistedstate用法")]),e._v(" "),t("ol",[t("li",[e._v("安装vuex-persistedstate\n可以使用npm或yarn来安装vuex-persistedstate：\nvuex-persistedstate是一个第三方库，可以将Vuex状态持久化到localStorage或sessionStorage中，实现页面刷新后依然保留Vuex状态的功能。以下是vuex-persistedstate的详细用法：")])]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("npm install vuex-persistedstate --save\n")])])]),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("yarn add vuex-persistedstate\n")])])]),t("ol",{attrs:{start:"2"}},[t("li",[e._v("在Vuex Store中使用vuex-persistedstate\n在Vuex Store中引入vuex-persistedstate，然后使用createPersistedState方法创建一个Vuex插件。createPersistedState方法可以接受一个选项对象，用于配置持久化存储的类型、存储的key、存储的白名单等。")])]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v('import createPersistedState from "vuex-persistedstate";\nimport Vue from "vue";\nimport Vuex from "vuex";\n\nVue.use(Vuex);\n\nconst store = new Vuex.Store({\n  state: {\n    count: 0\n  },\n  mutations: {\n    increment(state) {\n      state.count++;\n    },\n    decrement(state) {\n      state.count--;\n    }\n  },\n  plugins: [\n    createPersistedState({\n      storage: window.localStorage,\n      key: "my-app",\n      reducer: state => ({\n        count: state.count\n      })\n    })\n  ]\n});\n')])])]),t("p",[e._v('在这个例子中，我们使用createPersistedState方法创建一个Vuex插件，并将它添加到Vuex Store的plugins数组中。这个插件会将Vuex状态持久化到localStorage中，并将存储的key设置为"my-app"，同时只存储count属性的值。')]),e._v(" "),t("ol",{attrs:{start:"3"}},[t("li",[e._v("配置选项\ncreatePersistedState方法可以接受一个选项对象，用于配置持久化存储的类型、存储的key、存储的白名单等。以下是一些常用的选项：")])]),e._v(" "),t("p",[e._v('storage：用于指定持久化存储的类型，可以是localStorage或sessionStorage，默认是localStorage。\nkey：用于指定存储的key，默认是"vuex"。\nreducer：用于指定存储的白名单，可以是一个函数或数组。如果是函数，则接受一个state参数，返回一个包含要存储的属性的对象；如果是数组，则只存储数组中指定的属性。')]),e._v(" "),t("ol",{attrs:{start:"4"}},[t("li",[e._v("示例\n以下是一个完整的示例，展示了如何使用vuex-persistedstate将Vuex状态持久化到localStorage中：")])]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v('import createPersistedState from "vuex-persistedstate";\nimport Vue from "vue";\nimport Vuex from "vuex";\n\nVue.use(Vuex);\n\nconst store = new Vuex.Store({\n  state: {\n    count: 0,\n    message: "Hello, world!"\n  },\n  mutations: {\n    increment(state) {\n      state.count++;\n    },\n    decrement(state) {\n      state.count--;\n    },\n    setMessage(state, message) {\n      state.message = message;\n    }\n  },\n  plugins: [\n    createPersistedState({\n      storage: window.localStorage,\n      key: "my-app",\n      reducer: state =>\n    })\n  ]\n})\n')])])]),t("p",[e._v("上面的代码演示了如何使用vuex-persistedstate插件来让Vuex的数据在页面刷新后依然存在。具体来说，我们使用createPersistedState函数创建了一个插件实例，并将其作为Vuex的plugins选项传入Vuex.Store构造函数中。")]),e._v(" "),t("p",[e._v("createPersistedState函数接收一个options对象作为参数，其中包含以下选项：")]),e._v(" "),t("ul",[t("li",[e._v("storage：用于存储数据的存储对象，可以是localStorage、sessionStorage、cookie等。默认为localStorage。")]),e._v(" "),t("li",[e._v('key：用于存储数据的键名。默认为"vuex"。')]),e._v(" "),t("li",[e._v("paths：一个数组，包含了需要持久化的state中的数据属性的路径。默认为state的所有属性。")]),e._v(" "),t("li",[e._v("getState：一个函数，用于从存储中获取数据。默认为从storage中获取数据。")]),e._v(" "),t("li",[e._v("setState：一个函数，用于将数据存储到存储中。默认为将数据存储到storage中。")]),e._v(" "),t("li",[e._v("reducer：一个函数，用于过滤state中的属性，以减少存储的数据量。默认为不做任何过滤。")])]),e._v(" "),t("p",[e._v('在上面的代码中，我们将storage选项设置为localStorage，key选项设置为"my-app"，reducer选项设置为一个函数，该函数只返回了state中的count和message两个属性，用于减少存储的数据量。')]),e._v(" "),t("p",[e._v("通过使用vuex-persistedstate插件，我们可以让Vuex的数据在页面刷新后依然存在，从而提高应用的用户体验。")]),e._v(" "),t("h2",{attrs:{id:"总结"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#总结"}},[e._v("#")]),e._v(" 总结")]),e._v(" "),t("p",[e._v("总的来说，解决多页面应用中vuex数据共享的方法有很多，可以根据具体的情况选择合适的方法。但是需要注意的是，共享数据可能会带来数据安全性问题，需要根据具体需求和安全性要求来进行权衡。")])])}),[],!1,null,null,null);t.default=r.exports}}]);