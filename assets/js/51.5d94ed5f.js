(window.webpackJsonp=window.webpackJsonp||[]).push([[51],{340:function(s,t,a){"use strict";a.r(t);var v=a(5),r=Object(v.a)({},(function(){var s=this,t=s._self._c;return t("ContentSlotsDistributor",{attrs:{"slot-key":s.$parent.slotKey}},[t("h1",{attrs:{id:"js事件循环机制和node事件循环机制"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#js事件循环机制和node事件循环机制"}},[s._v("#")]),s._v(" js事件循环机制和node事件循环机制")]),s._v(" "),t("h2",{attrs:{id:"javascript-js-事件循环机制"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#javascript-js-事件循环机制"}},[s._v("#")]),s._v(" JavaScript (JS) 事件循环机制")]),s._v(" "),t("p",[s._v("JavaScript (JS) 事件循环机制是用于处理异步操作的机制。在 JS 中，异步操作包括网络请求、文件 I/O、定时器、事件回调等。当这些异步操作完成后，会生成相应的事件，事件循环会将这些事件分发到相应的事件回调函数中执行。事件循环是 JS 的单线程机制，意味着它只能在一个时间点执行一个任务。")]),s._v(" "),t("h3",{attrs:{id:"事件循环机制是-js-的基础-它包含以下几个主要部分"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#事件循环机制是-js-的基础-它包含以下几个主要部分"}},[s._v("#")]),s._v(" 事件循环机制是 JS 的基础，它包含以下几个主要部分：")]),s._v(" "),t("ol",[t("li",[t("p",[s._v("调用栈：JS 中的所有函数调用都在调用栈中管理，即一个函数被调用时会将其放入调用栈中，当函数执行完毕后会从调用栈中移除。调用栈是一个后进先出的数据结构。")])]),s._v(" "),t("li",[t("p",[s._v("任务队列：任务队列是 JS 事件循环机制中用于管理异步操作的完成事件的数据结构。当一个异步操作完成后，会将相应的事件放入任务队列中。任务队列分为两种类型：宏任务和微任务。宏任务包括 setTimeout、setInterval、XHR、UI 事件等，而微任务则包括 Promise 和 MutationObserver。")])]),s._v(" "),t("li",[t("p",[s._v("事件循环：事件循环是 JS 中的主要部分，它会不断地从任务队列中取出事件并将其分发到相应的事件回调函数中执行。当事件回调函数执行完毕后，会再次回到事件循环中等待下一个事件的到来。JS 中的事件循环是单线程的，意味着它只能在一个时间点执行一个任务。")])])]),s._v(" "),t("h3",{attrs:{id:"具体的事件循环过程如下"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#具体的事件循环过程如下"}},[s._v("#")]),s._v(" 具体的事件循环过程如下：")]),s._v(" "),t("ol",[t("li",[s._v("从任务队列中取出第一个任务（宏任务或微任务）并执行。")]),s._v(" "),t("li",[s._v("执行完当前任务后，如果任务队列中存在微任务，会按顺序将所有微任务全部取出并执行。")]),s._v(" "),t("li",[s._v("然后再从任务队列中取出下一个任务并执行，如此循环。")])]),s._v(" "),t("h2",{attrs:{id:"node-js事件循环机制"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#node-js事件循环机制"}},[s._v("#")]),s._v(" Node.js事件循环机制")]),s._v(" "),t("p",[s._v("Node.js 事件循环机制是一个基于 Chrome V8 引擎的 JavaScript 运行时环境，它支持运行 JavaScript 的服务端应用程序。Node.js 的事件循环机制和浏览器中的事件循环机制略有不同")]),s._v(" "),t("h3",{attrs:{id:"它主要包含以下几个部分"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#它主要包含以下几个部分"}},[s._v("#")]),s._v(" 它主要包含以下几个部分：")]),s._v(" "),t("ol",[t("li",[s._v("调用栈：和浏览器中的事件循环机制一样，Node.js 也使用调用栈来管理函数的调用和执行。")]),s._v(" "),t("li",[s._v("任务队列：Node.js 中的任务队列分为两种类型：宏任务和微任务。宏任务包括 I/O 操作和定时器，而微任务则包括 Promise 和 process.nextTick 等。")]),s._v(" "),t("li",[s._v("事件循环：Node.js 的事件循环机制和浏览器中的有些不同，它会首先处理所有的微任务，然后再处理宏任务。这个顺序保证了微任务的执行优先级高于宏任务。")])]),s._v(" "),t("p",[s._v("Node.js 和浏览器中的事件循环机制的主要区别在于任务队列的分类和处理顺序。Node.js 的事件循环机制更适合处理高并发的网络请求和 I/O 操作，而浏览器中的事件循环机制则更适合处理用户界面上的事件和动画效果等。")]),s._v(" "),t("h3",{attrs:{id:"具体的事件循环过程如下-2"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#具体的事件循环过程如下-2"}},[s._v("#")]),s._v(" 具体的事件循环过程如下：")]),s._v(" "),t("ol",[t("li",[s._v("从任务队列中取出第一个微任务并执行，直到微任务队列为空。")]),s._v(" "),t("li",[s._v("如果在执行微任务的过程中产生了新的微任务，将它们加入到微任务队列的末尾。")]),s._v(" "),t("li",[s._v("执行完所有微任务后，从宏任务队列中取出第一个宏任务并执行。")]),s._v(" "),t("li",[s._v("如此循环，直到所有任务都被执行完毕。")])])])}),[],!1,null,null,null);t.default=r.exports}}]);