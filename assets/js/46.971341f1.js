(window.webpackJsonp=window.webpackJsonp||[]).push([[46],{306:function(n,t,e){"use strict";e.r(t);var s=e(5),i=Object(s.a)({},(function(){var n=this,t=n._self._c;return t("ContentSlotsDistributor",{attrs:{"slot-key":n.$parent.slotKey}},[t("h1",{attrs:{id:"队列"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#队列"}},[n._v("#")]),n._v(" 队列")]),n._v(" "),t("h2",{attrs:{id:"概念"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#概念"}},[n._v("#")]),n._v(" 概念")]),n._v(" "),t("p",[n._v("在JavaScript中，队列（Queue）是一种常用的数据结构，它遵循先进先出（FIFO）的原则，即最先进入队列的元素最先被处理。\n在JavaScript中，队列通常使用数组来实现。可以通过数组的 push() 方法将元素添加到队列的末尾，通过 shift() 方法将队列的第一个元素移除并返回。\n在实际应用中，队列可以用来解决一些问题，比如：")]),n._v(" "),t("ul",[t("li",[n._v("异步任务队列：将异步任务添加到队列中，按顺序依次执行，确保异步任务不会重叠或冲突。")]),n._v(" "),t("li",[n._v("消息队列：用于消息的发布和订阅，确保消息按照先后顺序被处理。")]),n._v(" "),t("li",[n._v("页面路由：将待处理的页面请求添加到队列中，确保页面按照顺序进行渲染。\n需要注意的是，JavaScript中的队列操作是基于数组实现的，如果需要处理大量的队列操作，可能会对性能造成一定的影响。在实际应用中，可以使用专门的队列数据结构库来实现高效的队列操作。")])]),n._v(" "),t("h2",{attrs:{id:"算法题"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#算法题"}},[n._v("#")]),n._v(" 算法题")]),n._v(" "),t("h3",{attrs:{id:"实现一个基本的队列-包含入队、出队、获取队首元素和队列长度的方法。"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#实现一个基本的队列-包含入队、出队、获取队首元素和队列长度的方法。"}},[n._v("#")]),n._v(" 实现一个基本的队列，包含入队、出队、获取队首元素和队列长度的方法。")]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[n._v("class Queue {\n  constructor() {\n    this.items = [];\n  }\n\n  enqueue(element) {\n    this.items.push(element);\n  }\n\n  dequeue() {\n    if (this.isEmpty()) {\n      return null;\n    }\n    return this.items.shift();\n  }\n\n  front() {\n    if (this.isEmpty()) {\n      return null;\n    }\n    return this.items[0];\n  }\n\n  size() {\n    return this.items.length;\n  }\n\n  isEmpty() {\n    return this.items.length === 0;\n  }\n}\n\n")])])]),t("h3",{attrs:{id:"判断一个字符串是否为回文字符串-要求忽略空格和标点符号。例如-racecar-和-a-man-a-plan-a-canal-panama-都是回文字符串。"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#判断一个字符串是否为回文字符串-要求忽略空格和标点符号。例如-racecar-和-a-man-a-plan-a-canal-panama-都是回文字符串。"}},[n._v("#")]),n._v(" 判断一个字符串是否为回文字符串，要求忽略空格和标点符号。例如，'racecar' 和 'A man, a plan, a canal: Panama' 都是回文字符串。")]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[n._v("function isPalindrome(str) {\n  const queue = new Queue();\n  const stack = [];\n\n  // 将字符串中的字母入队列和栈中\n  for (let i = 0; i < str.length; i++) {\n    const char = str[i].toLowerCase();\n    if (/[a-z]/.test(char)) {\n      queue.enqueue(char);\n      stack.push(char);\n    }\n  }\n\n  // 依次比较队列和栈中的元素是否相同\n  while (!queue.isEmpty()) {\n    if (queue.dequeue() !== stack.pop()) {\n      return false;\n    }\n  }\n  return true;\n}\n")])])]),t("h3",{attrs:{id:"用队列实现一个栈-并给出-push-和-pop-方法的实现。"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#用队列实现一个栈-并给出-push-和-pop-方法的实现。"}},[n._v("#")]),n._v(" 用队列实现一个栈，并给出 push() 和 pop() 方法的实现。")]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[n._v("class Stack {\n  constructor() {\n    this.queue = new Queue();\n  }\n\n  push(element) {\n    this.queue.enqueue(element);\n  }\n\n  pop() {\n    if (this.isEmpty()) {\n      return null;\n    }\n\n    const size = this.queue.size();\n    for (let i = 0; i < size - 1; i++) {\n      this.queue.enqueue(this.queue.dequeue());\n    }\n    return this.queue.dequeue();\n  }\n\n  isEmpty() {\n    return this.queue.isEmpty();\n  }\n}\n")])])]),t("h3",{attrs:{id:"用队列实现一个优先队列-队列元素包含值和优先级-优先级越高的元素排在队列的前面。"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#用队列实现一个优先队列-队列元素包含值和优先级-优先级越高的元素排在队列的前面。"}},[n._v("#")]),n._v(" 用队列实现一个优先队列，队列元素包含值和优先级，优先级越高的元素排在队列的前面。")]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[n._v("class PriorityQueue {\n  constructor() {\n    this.items = [];\n  }\n\n  enqueue(element, priority) {\n    const newItem = { element, priority };\n    let added = false;\n\n    for (let i = 0; i < this.items.length; i++) {\n      if (newItem.priority < this.items[i].priority) {\n        this.items.splice(i, 0, newItem);\n        added = true;\n        break;\n      }\n    }\n\n    if (!added) {\n      this.items.push(newItem);\n    }\n  }\n\n  dequeue() {\n    if (this.isEmpty()) {\n      return null;\n    }\n    return this.items.shift().element;\n  }\n\n  front() {\n    if (this.isEmpty()) {\n      return null;\n    }\n    return this.items[0].element;\n  }\n\n  size() {\n    return this.items.length;\n  }\n\n  isEmpty() {\n    return this.items.length === 0;\n  }\n}\n")])])]),t("h3",{attrs:{id:"用队列实现一个循环队列-并给出入队、出队、获取队首元素和队列长度的方法。循环队列是一种特殊的队列-它允许在队列的末尾插入新元素-同时在队列的开头删除元素-使得队列看起来像一个环形。"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#用队列实现一个循环队列-并给出入队、出队、获取队首元素和队列长度的方法。循环队列是一种特殊的队列-它允许在队列的末尾插入新元素-同时在队列的开头删除元素-使得队列看起来像一个环形。"}},[n._v("#")]),n._v(" 用队列实现一个循环队列，并给出入队、出队、获取队首元素和队列长度的方法。循环队列是一种特殊的队列，它允许在队列的末尾插入新元素，同时在队列的开头删除元素，使得队列看起来像一个环形。")]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[n._v("class CircularQueue {\n  constructor(k) {\n    this.items = new Array(k);\n    this.front = 0;\n    this.rear = 0;\n    this.size = 0;\n  }\n\n  enqueue(element) {\n    if (this.isFull()) {\n      return false;\n    }\n    this.items[this.rear] = element;\n    this.rear = (this.rear + 1) % this.items.length;\n    this.size++;\n    return true;\n  }\n\n  dequeue() {\n    if (this.isEmpty()) {\n      return false;\n    }\n    const removedElement = this.items[this.front];\n    this.items[this.front] = null;\n    this.front = (this.front + 1) % this.items.length;\n    this.size--;\n    return removedElement;\n  }\n\n  front() {\n    if (this.isEmpty()) {\n      return null;\n    }\n    return this.items[this.front];\n  }\n\n  getSize() {\n    return this.size;\n  }\n\n  isEmpty() {\n    return this.getSize() === 0;\n  }\n\n  isFull() {\n    return this.getSize() === this.items.length;\n  }\n}\n")])])]),t("h3",{attrs:{id:"设计一个支持-push、pop、top-和-getmin-操作的最小栈。其中-getmin-方法返回栈中的最小元素。"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#设计一个支持-push、pop、top-和-getmin-操作的最小栈。其中-getmin-方法返回栈中的最小元素。"}},[n._v("#")]),n._v(" 设计一个支持 push、pop、top 和 getMin 操作的最小栈。其中，getMin 方法返回栈中的最小元素。")]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[n._v("class MinStack {\n  constructor() {\n    this.stack = [];\n    this.minStack = [];\n  }\n\n  push(element) {\n    if (this.minStack.length === 0 || element <= this.getMin()) {\n      this.minStack.push(element);\n    }\n    this.stack.push(element);\n  }\n\n  pop() {\n    if (this.stack.length === 0) {\n      return null;\n    }\n    const poppedElement = this.stack.pop();\n    if (poppedElement === this.getMin()) {\n      this.minStack.pop();\n    }\n    return poppedElement;\n  }\n\n  top() {\n    if (this.stack.length === 0) {\n      return null;\n    }\n    return this.stack[this.stack.length - 1];\n  }\n\n  getMin() {\n    if (this.minStack.length === 0) {\n      return null;\n    }\n    return this.minStack[this.minStack.length - 1];\n  }\n}\n")])])]),t("h3",{attrs:{id:"给定一个由数字组成的数组-nums-和一个数字-k-计算数组中每个大小为-k-的连续子数组的平均值-并返回这些平均值组成的数组。"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#给定一个由数字组成的数组-nums-和一个数字-k-计算数组中每个大小为-k-的连续子数组的平均值-并返回这些平均值组成的数组。"}},[n._v("#")]),n._v(" 给定一个由数字组成的数组 nums 和一个数字 k，计算数组中每个大小为 k 的连续子数组的平均值，并返回这些平均值组成的数组。")]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[n._v("function findAverageOfSubarrays(nums, k) {\n  const result = [];\n  let windowSum = 0;\n  let windowStart = 0;\n\n  for (let windowEnd = 0; windowEnd < nums.length; windowEnd++) {\n    windowSum += nums[windowEnd];\n\n    if (windowEnd >= k - 1) {\n      result.push(windowSum / k);\n      windowSum -= nums[windowStart];\n      windowStart++;\n    }\n  }\n\n  return result;\n}\n")])])]),t("h3",{attrs:{id:"给定一个由数字组成的数组-nums-和一个数字-k-返回所有连续子数组中的最小值。"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#给定一个由数字组成的数组-nums-和一个数字-k-返回所有连续子数组中的最小值。"}},[n._v("#")]),n._v(" 给定一个由数字组成的数组 nums 和一个数字 k，返回所有连续子数组中的最小值。")]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[n._v("function findMinInSubarrays(nums, k) {\n  const result = [];\n  let min = Infinity;\n  let windowStart = 0;\n\n  for (let windowEnd = 0; windowEnd < nums.length; windowEnd++) {\n    min = Math.min(min, nums[windowEnd]);\n\n    if (windowEnd >= k - 1) {\n      result.push(min);\n      if (nums[windowStart] === min) {\n        min = Infinity;\n        for (let i = windowStart + 1; i <= windowEnd; i++) {\n          min = Math.min(min, nums[i]);\n        }\n      }\n      windowStart++;\n    }\n  }\n\n  return result;\n}\n")])])]),t("h3",{attrs:{id:"给定两个整数数组-nums1-和-nums2-以及一个整数-k。定义一对值-u-v-其中第一个元素来自-nums1-第二个元素来自-nums2。找到和最小的-k-对数字-u1-v1-u2-v2-uk-vk-。"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#给定两个整数数组-nums1-和-nums2-以及一个整数-k。定义一对值-u-v-其中第一个元素来自-nums1-第二个元素来自-nums2。找到和最小的-k-对数字-u1-v1-u2-v2-uk-vk-。"}},[n._v("#")]),n._v(" 给定两个整数数组 nums1 和 nums2，以及一个整数 k。定义一对值 (u,v)，其中第一个元素来自 nums1，第二个元素来自 nums2。找到和最小的 k 对数字 (u1,v1), (u2,v2) ... (uk,vk)。")]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[n._v("function findKPairsWithSmallestSums(nums1, nums2, k) {\n  const result = [];\n  if (nums1.length === 0 || nums2.length === 0 || k === 0) {\n    return result;\n  }\n\n  const heap = new MinHeap((a, b) => a[0] + a[1] - b[0] - b[1]);\n\n  for (let i = 0; i < Math.min(nums1.length, k); i++) {\n    heap.push([nums1[i], nums2[0], 0]);\n  }\n\n  while (k-- > 0 && !heap.isEmpty()) {\n    const [num1, num2, index2] = heap.pop();\n    result.push([num1, num2]);\n    if (index2 + 1 < nums2.length) {\n      heap.push([num1, nums2[index2 + 1], index2 + 1]);\n    }\n  }\n\n  return result;\n}\n\nclass MinHeap {\n  constructor(compareFn) {\n    this.compare = compareFn || ((a, b) => a - b);\n    this.heap = [];\n  }\n\n  get size() {\n    return this.heap.length;\n  }\n\n  isEmpty() {\n    return this.size === 0;\n  }\n\n  peek() {\n    return this.heap[0];\n  }\n\n  push(value) {\n    this.heap.push(value);\n    this.bubbleUp(this.size - 1);\n  }\n\n  pop() {\n    if (this.isEmpty()) {\n      return null;\n    }\n    const root = this.heap[0];\n    const last = this.heap.pop();\n    if (!this.isEmpty()) {\n      this.heap[0] = last;\n      this.bubbleDown(0);\n    }\n    return root;\n  }\n\n  bubbleUp(index) {\n    while (index > 0) {\n      const parentIndex = Math.floor((index - 1) / 2);\n      if (this.compare(this.heap[index], this.heap[parentIndex]) >= 0) {\n        break;\n      }\n      this.swap(index, parentIndex);\n      index = parentIndex;\n    }\n  }\n\n  bubbleDown(index) {\n    while (index < this.size) {\n      const leftIndex = index * 2 + 1;\n      const rightIndex = index * 2 + 2;\n      let smallerIndex = index;\n      if (leftIndex < this.size && this.compare(this.heap[leftIndex], this.heap[smallerIndex]) < 0) {\n        smallerIndex = leftIndex;\n      }\n      if (rightIndex < this.size && this.compare(this.heap[rightIndex], this.heap[smallerIndex]) < 0) {\n        smallerIndex = rightIndex;\n      }\n      if (smallerIndex === index) {\n        break;\n      }\n      this.swap(index, smallerIndex);\n      index = smallerIndex;\n    }\n  }\n\n  swap(index1, index2) {\n    [this.heap[index1], this.heap[index2]] = [this.heap[index2], this.heap[index1]];\n  }\n}\n\n")])])]),t("p",[n._v("解析：本题使用了堆（优先队列）的数据结构。在使用堆的时候，我们需要维护一个大小为 k 的堆，堆中")])])}),[],!1,null,null,null);t.default=i.exports}}]);