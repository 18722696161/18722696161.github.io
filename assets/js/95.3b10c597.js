(window.webpackJsonp=window.webpackJsonp||[]).push([[95],{333:function(t,n,e){"use strict";e.r(n);var a=e(5),o=Object(a.a)({},(function(){var t=this,n=t._self._c;return n("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[n("h1",{attrs:{id:"patch函数"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#patch函数"}},[t._v("#")]),t._v(" patch函数")]),t._v(" "),n("p",[t._v("patch 函数是 Vue.js 用来将虚拟 DOM 转换成真实 DOM 并更新视图的函数。在 Vue.js 中，每个组件都有一个虚拟 DOM 树，当组件需要重新渲染时，Vue.js 会通过比较新旧虚拟 DOM 树的差异，然后根据差异来更新视图。这个过程中就使用到了 patch 函数。")]),t._v(" "),n("p",[t._v("patch 函数接收两个参数，分别是旧的虚拟 DOM 和新的虚拟 DOM，它会比较这两个虚拟 DOM 的差异，并根据差异来更新视图。在更新视图时，patch 函数会尽量复用已有的 DOM 元素，而不是直接创建新的 DOM 元素，以提高性能。")]),t._v(" "),n("p",[t._v("在 Vue.js 中，patch 函数通常是由虚拟 DOM 渲染器自动调用的，不需要手动调用。但是，在一些高级场景下，我们可能需要手动调用 patch 函数来更新视图，比如在自定义指令或渲染函数中。")]),t._v(" "),n("p",[t._v("下面是一个简单的示例，演示了如何手动调用 patch 函数来更新视图：")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("import { createApp, h } from 'vue'\n\nconst app = createApp({\n  data() {\n    return {\n      count: 0\n    }\n  },\n  render() {\n    return h('div', { class: 'container' }, [\n      h('p', {}, `Count: ${this.count}`),\n      h('button', { onClick: this.handleClick }, 'Increment')\n    ])\n  },\n  methods: {\n    handleClick() {\n      this.count++\n      this.updateView()\n    },\n    updateView() {\n      const oldVNode = this.$el\n      const newVNode = this.render()\n      this.$el = this.$root.$el = patch(oldVNode, newVNode)\n    }\n  }\n})\n\nconst container = document.getElementById('app')\nconst oldVNode = container.firstChild\nconst newVNode = app.mount(container).$el\n\npatch(oldVNode, newVNode)\n")])])]),n("p",[t._v("在上面的示例中，我们手动调用了 patch 函数来更新视图。首先，我们通过 app.mount 方法将根组件挂载到一个 DOM 容器上，并获取新的虚拟 DOM 树。然后，我们从容器中获取旧的虚拟 DOM 树，并将它作为 patch 函数的第一个参数，将新的虚拟 DOM 树作为第二个参数，来更新视图。")])])}),[],!1,null,null,null);n.default=o.exports}}]);