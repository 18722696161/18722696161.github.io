(window.webpackJsonp=window.webpackJsonp||[]).push([[43],{328:function(t,n,s){"use strict";s.r(n);var a=s(5),e=Object(a.a)({},(function(){var t=this,n=t._self._c;return n("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[n("h1",{attrs:{id:"栈"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#栈"}},[t._v("#")]),t._v(" 栈")]),t._v(" "),n("h2",{attrs:{id:"概念"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#概念"}},[t._v("#")]),t._v(" 概念")]),t._v(" "),n("p",[t._v("在 JavaScript 中，栈是一种常见的数据结构，常用于实现函数调用、表达式求值、括号匹配等算法问题。栈是一种后进先出（LIFO）的数据结构，也就是最后压入的元素最先被弹出。\n在 JavaScript 中，可以使用数组或链表来实现栈。下面我们以数组实现栈为例进行介绍。")]),t._v(" "),n("h3",{attrs:{id:"数组实现栈"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#数组实现栈"}},[t._v("#")]),t._v(" 数组实现栈：")]),t._v(" "),n("p",[t._v("数组实现栈比较简单，可以使用数组的 push 和 pop 方法来实现栈的 push 和 pop 操作。push 方法用于向栈中添加元素，pop 方法用于从栈中弹出元素。此外，还可以使用 length 属性来获取栈的大小。")]),t._v(" "),n("h2",{attrs:{id:"算法题"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#算法题"}},[t._v("#")]),t._v(" 算法题")]),t._v(" "),n("h3",{attrs:{id:"用栈实现一个队列。"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#用栈实现一个队列。"}},[t._v("#")]),t._v(" 用栈实现一个队列。")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("class StackQueue {\n  constructor() {\n    this.stack1 = [];\n    this.stack2 = [];\n  }\n\n  enqueue(value) {\n    this.stack1.push(value);\n  }\n\n  dequeue() {\n    if (this.stack2.length === 0) {\n      while (this.stack1.length > 0) {\n        this.stack2.push(this.stack1.pop());\n      }\n    }\n    return this.stack2.pop();\n  }\n\n  isEmpty() {\n    return this.stack1.length === 0 && this.stack2.length === 0;\n  }\n}\n\n")])])]),n("p",[t._v("解析：这里用两个栈来实现一个队列，其中一个栈用来入队，另一个栈用来出队。入队时直接往第一个栈里面压入元素，出队时，如果第二个栈为空，则将第一个栈中所有元素出栈并压入第二个栈中，然后再从第二个栈中出栈即可。")]),t._v(" "),n("h3",{attrs:{id:"用栈实现一个最小栈-使得-push、pop、getmin-操作的时间复杂度都是-o-1-。"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#用栈实现一个最小栈-使得-push、pop、getmin-操作的时间复杂度都是-o-1-。"}},[t._v("#")]),t._v(" 用栈实现一个最小栈，使得 push、pop、getMin 操作的时间复杂度都是 O(1)。")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("class MinStack {\n  constructor() {\n    this.stack = [];\n    this.minStack = [];\n  }\n\n  push(value) {\n    this.stack.push(value);\n    if (this.minStack.length === 0 || value <= this.getMin()) {\n      this.minStack.push(value);\n    }\n  }\n\n  pop() {\n    const value = this.stack.pop();\n    if (value === this.getMin()) {\n      this.minStack.pop();\n    }\n    return value;\n  }\n\n  getMin() {\n    return this.minStack[this.minStack.length - 1];\n  }\n\n  isEmpty() {\n    return this.stack.length === 0;\n  }\n}\n\n")])])]),n("p",[t._v("解析：这里用两个栈来实现一个最小栈，其中一个栈用来存储所有元素，另一个栈用来存储当前栈的最小值。在 push 操作时，如果新加入的值比当前最小值小或者最小栈为空，就把这个值压入最小栈。在 pop 操作时，如果弹出的值是当前最小值，就从最小栈中弹出这个值。")]),t._v(" "),n("h3",{attrs:{id:"给定一个数组-找到每个元素右侧第一个比它大的元素-如果不存在则为-1。"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#给定一个数组-找到每个元素右侧第一个比它大的元素-如果不存在则为-1。"}},[t._v("#")]),t._v(" 给定一个数组，找到每个元素右侧第一个比它大的元素，如果不存在则为 -1。")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("function findNextGreaterElement(arr) {\n  const stack = [];\n  const result = new Array(arr.length).fill(-1);\n  for (let i = 0; i < arr.length; i++) {\n    while (stack.length > 0 && arr[i] > arr[stack[stack.length - 1]]) {\n      result[stack.pop()] = arr[i];\n    }\n    stack.push(i);\n  }\n  return result;\n}\n\n")])])]),n("p",[t._v("解析：这里用一个栈来记录数组中的下标。从左往右遍历数组，对于每个元素，如果栈顶元素比它小，则弹出栈顶元素，并把栈顶元素的下标作为结果数组中相应位置的值。最后栈中剩余的元素的结果都是 -1。")]),t._v(" "),n("h3",{attrs:{id:"给定一个字符串-判断括号是否匹配。"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#给定一个字符串-判断括号是否匹配。"}},[t._v("#")]),t._v(" 给定一个字符串，判断括号是否匹配。")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("function isValidParentheses(s) {\n  const stack = [];\n  for (let i = 0; i < s.length; i++) {\n    const c = s.charAt(i);\n    if (c === '(' || c === '[' || c === '{') {\n      stack.push(c);\n    } else if (c === ')' && stack[stack.length - 1] === '(') {\n      stack.pop();\n    } else if (c === ']' && stack[stack.length - 1] === '[') {\n      stack.pop();\n    } else if (c === '}' && stack[stack.length - 1] === '{') {\n      stack.pop();\n    } else {\n      return false;\n    }\n  }\n  return stack.length === 0;\n}\n")])])]),n("p",[t._v("解析：这里用一个栈来记录左括号。从左往右遍历字符串，如果是左括号，则入栈；如果是右括号，则弹出栈顶元素并判断是否匹配。如果不匹配或者栈为空，则返回 false。")]),t._v(" "),n("h3",{attrs:{id:"给定一个字符串-求最长的有效括号子串的长度。"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#给定一个字符串-求最长的有效括号子串的长度。"}},[t._v("#")]),t._v(" 给定一个字符串，求最长的有效括号子串的长度。")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("function longestValidParentheses(s) {\n  const stack = [-1];\n  let max = 0;\n  for (let i = 0; i < s.length; i++) {\n    if (s.charAt(i) === '(') {\n      stack.push(i);\n    } else {\n      stack.pop();\n      if (stack.length === 0) {\n        stack.push(i);\n      } else {\n        max = Math.max(max, i - stack[stack.length - 1]);\n      }\n    }\n  }\n  return max;\n}\n")])])]),n("p",[t._v("解析：这里用一个栈来记录左括号的下标。从左往右遍历字符串，如果是左括号，则将它的下标入栈；如果是右括号，则弹出栈顶元素，并计算当前位置和栈顶元素之间的距离。最终返回最长的距离即可。")]),t._v(" "),n("h3",{attrs:{id:"给定一个字符串-求最长的回文子串。"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#给定一个字符串-求最长的回文子串。"}},[t._v("#")]),t._v(" 给定一个字符串，求最长的回文子串。")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("function longestPalindrome(s) {\n  let max = '';\n  for (let i = 0; i < s.length; i++) {\n    let j = i, k = i;\n    while (k < s.length - 1 && s[k] === s[k + 1]) {\n      k++;\n    }\n    while (j > 0 && k < s.length - 1 && s[j - 1] === s[k + 1]) {\n      j--;\n      k++;\n    }\n    const substr = s.substring(j, k + 1);\n    if (substr.length > max.length) {\n      max = substr;\n    }\n  }\n  return max;\n}\n")])])]),n("p",[t._v("解析：这里用两个指针 j 和 k 来分别从中心向左右扩展，每次都判断两个指针指向的字符是否相等，如果相等则继续扩展。同时还要注意处理奇数和偶数长度的回文子串。最终返回最长的回文子串即可。")]),t._v(" "),n("h3",{attrs:{id:"给定一个数组-找到所有子数组的和最大值。"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#给定一个数组-找到所有子数组的和最大值。"}},[t._v("#")]),t._v(" 给定一个数组，找到所有子数组的和最大值。")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("function maxSubArray(nums) {\n  let maxSum = nums[0];\n  let currentSum = nums[0];\n  for (let i = 1; i < nums.length; i++) {\n    currentSum = Math.max(currentSum + nums[i], nums[i]);\n    maxSum = Math.max(maxSum, currentSum);\n  }\n  return maxSum;\n}\n\n")])])]),n("p",[t._v("解析：这里用一个变量 currentSum 来记录当前的子数组和，另一个变量 maxSum 来记录最大的子数组和。从第二个元素开始遍历数组，每次将 currentSum 更新为 currentSum + nums[i] 和 nums[i] 中的较大值，同时更新 maxSum 为 maxSum 和 currentSum 中的较大值。最终返回 maxSum 即可。")]),t._v(" "),n("h3",{attrs:{id:"给定一个二叉树-求它的最大深度。"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#给定一个二叉树-求它的最大深度。"}},[t._v("#")]),t._v(" 给定一个二叉树，求它的最大深度。")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("function maxDepth(root) {\n  if (root === null) {\n    return 0;\n  }\n  const leftDepth = maxDepth(root.left);\n  const rightDepth = maxDepth(root.right);\n  return Math.max(leftDepth, rightDepth) + 1;\n}\n")])])]),n("p",[t._v("解析：这里用递归来计算二叉树的最大深度。对于每个节点，计算左子树的最大深度和右子树的最大深度，并返回它们中的较大值加上 1，即为当前节点的最大深度。最终返回根节点的最大深度即可。")]),t._v(" "),n("h3",{attrs:{id:"给定一个数组-找到其中第-k-大的元素。"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#给定一个数组-找到其中第-k-大的元素。"}},[t._v("#")]),t._v(" 给定一个数组，找到其中第 k 大的元素。")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("function findKthLargest(nums, k) {\n  const pivot = nums[0];\n  const left = [];\n  const right = [];\n  for (let i = 1; i < nums.length; i++) {\n    if (nums[i] > pivot) {\n      left.push(nums[i]);\n    } else {\n      right.push(nums[i]);\n    }\n  }\n  if (left.length >= k) {\n    return findKthLargest(left, k);\n  } else if (left.length + 1 === k) {\n    return pivot;\n  } else {\n    return findKthLargest(right, k - left.length - 1);\n  }\n}\n")])])]),n("p",[t._v("解析：这里使用快速排序的思想来解决问题，选择数组中的一个元素作为枢纽元素 pivot，然后将比 pivot 大的元素放到一个数组 left 中，比 pivot 小的元素放到另一个数组 right 中。如果 left 的长度大于等于 k，说明第 k 大的元素在 left 中，否则如果 left 的长度加上 1 等于 k，说明 pivot 就是第 k 大的元素，否则第 k 大的元素在 right 中，需要在 right 中查找第 k - left.length - 1 大的元素。最终返回第 k 大的元素即可。")]),t._v(" "),n("h3",{attrs:{id:"给定一个字符串-s-和一个字符串-t-判断-s-是否为-t-的子序列。"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#给定一个字符串-s-和一个字符串-t-判断-s-是否为-t-的子序列。"}},[t._v("#")]),t._v(" 给定一个字符串 s 和一个字符串 t，判断 s 是否为 t 的子序列。")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("function isSubsequence(s, t) {\n  let i = 0, j = 0;\n  while (i < s.length && j < t.length) {\n    if (s[i] === t[j]) {\n      i++;\n    }\n    j++;\n  }\n  return i === s.length;\n}\n")])])]),n("p",[t._v("解析：这里使用双指针来解决问题，分别用 i 和 j 来指向 s 和 t 的字符，每次判断 s[i] 是否等于 t[j]，如果相等则将 i 加 1，否则将 j 加 1。最终判断 i 是否等于 s 的长度即可。如果 i 等于 s 的长度，说明 s 是 t 的子序列，否则不是。")])])}),[],!1,null,null,null);n.default=e.exports}}]);