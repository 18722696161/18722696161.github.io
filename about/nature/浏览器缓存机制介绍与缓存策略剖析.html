<!DOCTYPE html>
<html lang="ZH">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>三、浏览器缓存机制介绍与缓存策略剖析 | phr技术博客</title>
    <meta name="generator" content="VuePress 1.9.9">
    <link rel="icon" href="/favicon.ico">
    <meta name="description" content=" ">
    
    <link rel="preload" href="/assets/css/0.styles.b10b5fb3.css" as="style"><link rel="preload" href="/assets/js/app.6365c275.js" as="script"><link rel="preload" href="/assets/js/2.f728fa66.js" as="script"><link rel="preload" href="/assets/js/6.a279f8e6.js" as="script"><link rel="preload" href="/assets/js/13.35cba3fc.js" as="script"><link rel="prefetch" href="/assets/js/10.93260224.js"><link rel="prefetch" href="/assets/js/100.f6b8ec7d.js"><link rel="prefetch" href="/assets/js/101.967b6c5a.js"><link rel="prefetch" href="/assets/js/102.21711343.js"><link rel="prefetch" href="/assets/js/103.d49ec33e.js"><link rel="prefetch" href="/assets/js/104.977a3b03.js"><link rel="prefetch" href="/assets/js/105.b99482a1.js"><link rel="prefetch" href="/assets/js/106.e4a47e6c.js"><link rel="prefetch" href="/assets/js/107.0fbdc788.js"><link rel="prefetch" href="/assets/js/108.3c5b4338.js"><link rel="prefetch" href="/assets/js/109.3684a685.js"><link rel="prefetch" href="/assets/js/11.49b33569.js"><link rel="prefetch" href="/assets/js/110.baed003e.js"><link rel="prefetch" href="/assets/js/111.83769994.js"><link rel="prefetch" href="/assets/js/112.946c5f99.js"><link rel="prefetch" href="/assets/js/12.a36537bf.js"><link rel="prefetch" href="/assets/js/14.0e48b2e5.js"><link rel="prefetch" href="/assets/js/15.e55cd707.js"><link rel="prefetch" href="/assets/js/16.f872fbeb.js"><link rel="prefetch" href="/assets/js/17.f7a4d99b.js"><link rel="prefetch" href="/assets/js/18.ba229207.js"><link rel="prefetch" href="/assets/js/19.92de1ede.js"><link rel="prefetch" href="/assets/js/20.3188b6de.js"><link rel="prefetch" href="/assets/js/21.720e9417.js"><link rel="prefetch" href="/assets/js/22.fa36b946.js"><link rel="prefetch" href="/assets/js/23.ef58e05b.js"><link rel="prefetch" href="/assets/js/24.881d6b82.js"><link rel="prefetch" href="/assets/js/25.8af9bcbe.js"><link rel="prefetch" href="/assets/js/26.43432835.js"><link rel="prefetch" href="/assets/js/27.0f7b8718.js"><link rel="prefetch" href="/assets/js/28.a0c57751.js"><link rel="prefetch" href="/assets/js/29.c1658d5b.js"><link rel="prefetch" href="/assets/js/3.1568aedc.js"><link rel="prefetch" href="/assets/js/30.c4fc88ff.js"><link rel="prefetch" href="/assets/js/31.1fc1fc07.js"><link rel="prefetch" href="/assets/js/32.d63a6056.js"><link rel="prefetch" href="/assets/js/33.8b8854ed.js"><link rel="prefetch" href="/assets/js/34.7f7a6517.js"><link rel="prefetch" href="/assets/js/35.1628cb9c.js"><link rel="prefetch" href="/assets/js/36.3703f0c9.js"><link rel="prefetch" href="/assets/js/37.9a8be999.js"><link rel="prefetch" href="/assets/js/38.1bad6e08.js"><link rel="prefetch" href="/assets/js/39.887115b5.js"><link rel="prefetch" href="/assets/js/4.529cb57e.js"><link rel="prefetch" href="/assets/js/40.cb099c93.js"><link rel="prefetch" href="/assets/js/41.b39ca612.js"><link rel="prefetch" href="/assets/js/42.6a0ec8ac.js"><link rel="prefetch" href="/assets/js/43.de1b9001.js"><link rel="prefetch" href="/assets/js/44.133a895c.js"><link rel="prefetch" href="/assets/js/45.1961312a.js"><link rel="prefetch" href="/assets/js/46.971341f1.js"><link rel="prefetch" href="/assets/js/47.7bc2173e.js"><link rel="prefetch" href="/assets/js/48.5d895a7e.js"><link rel="prefetch" href="/assets/js/49.638058f6.js"><link rel="prefetch" href="/assets/js/5.387bf8e2.js"><link rel="prefetch" href="/assets/js/50.e742ad4c.js"><link rel="prefetch" href="/assets/js/51.5d94ed5f.js"><link rel="prefetch" href="/assets/js/52.55a51aaa.js"><link rel="prefetch" href="/assets/js/53.1ba60b2b.js"><link rel="prefetch" href="/assets/js/54.73a995e7.js"><link rel="prefetch" href="/assets/js/55.4e018c53.js"><link rel="prefetch" href="/assets/js/56.6cb78c59.js"><link rel="prefetch" href="/assets/js/57.563d5c97.js"><link rel="prefetch" href="/assets/js/58.f8954d6d.js"><link rel="prefetch" href="/assets/js/59.3d2a7fdb.js"><link rel="prefetch" href="/assets/js/60.5a3e1e46.js"><link rel="prefetch" href="/assets/js/61.7e804132.js"><link rel="prefetch" href="/assets/js/62.e5287e80.js"><link rel="prefetch" href="/assets/js/63.be538378.js"><link rel="prefetch" href="/assets/js/64.317aebd1.js"><link rel="prefetch" href="/assets/js/65.7643d336.js"><link rel="prefetch" href="/assets/js/66.9b0f8d09.js"><link rel="prefetch" href="/assets/js/67.756bb42b.js"><link rel="prefetch" href="/assets/js/68.c56721fc.js"><link rel="prefetch" href="/assets/js/69.5f86f31b.js"><link rel="prefetch" href="/assets/js/7.0f2b711c.js"><link rel="prefetch" href="/assets/js/70.417864a8.js"><link rel="prefetch" href="/assets/js/71.4aee4693.js"><link rel="prefetch" href="/assets/js/72.c013fc2a.js"><link rel="prefetch" href="/assets/js/73.50ca59ad.js"><link rel="prefetch" href="/assets/js/74.b627791d.js"><link rel="prefetch" href="/assets/js/75.f5879061.js"><link rel="prefetch" href="/assets/js/76.e7be1127.js"><link rel="prefetch" href="/assets/js/77.aafb8bbb.js"><link rel="prefetch" href="/assets/js/78.0f2b7ba1.js"><link rel="prefetch" href="/assets/js/79.ee2c7dff.js"><link rel="prefetch" href="/assets/js/8.fbc348ff.js"><link rel="prefetch" href="/assets/js/80.d0d7ac73.js"><link rel="prefetch" href="/assets/js/81.e10b54fc.js"><link rel="prefetch" href="/assets/js/82.03db26fd.js"><link rel="prefetch" href="/assets/js/83.89bcaab3.js"><link rel="prefetch" href="/assets/js/84.e3c968c0.js"><link rel="prefetch" href="/assets/js/85.8d36c455.js"><link rel="prefetch" href="/assets/js/86.2d239c5d.js"><link rel="prefetch" href="/assets/js/87.0bc771d9.js"><link rel="prefetch" href="/assets/js/88.f8a1db97.js"><link rel="prefetch" href="/assets/js/89.1671c085.js"><link rel="prefetch" href="/assets/js/9.600c48e6.js"><link rel="prefetch" href="/assets/js/90.6a7cb76f.js"><link rel="prefetch" href="/assets/js/91.96dda1bd.js"><link rel="prefetch" href="/assets/js/92.defa3643.js"><link rel="prefetch" href="/assets/js/93.1a469c8a.js"><link rel="prefetch" href="/assets/js/94.d9b30b49.js"><link rel="prefetch" href="/assets/js/95.3b10c597.js"><link rel="prefetch" href="/assets/js/96.ee7c131a.js"><link rel="prefetch" href="/assets/js/97.dbf5d04e.js"><link rel="prefetch" href="/assets/js/98.60f0f169.js"><link rel="prefetch" href="/assets/js/99.58cbe020.js">
    <link rel="stylesheet" href="/assets/css/0.styles.b10b5fb3.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/" class="home-link router-link-active"><!----> <span class="site-name">phr技术博客</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/" class="nav-link">
  首页
</a></div><div class="nav-item"><a href="/about/project/项目总结.html" class="nav-link">
  项目经历
</a></div><div class="nav-item"><a href="/about/project/微前端.html" class="nav-link">
  微前端
</a></div><div class="nav-item"><a href="/about/project/性能监控.html" class="nav-link">
  性能监控
</a></div><div class="nav-item"><a href="/about/project/小程序架构设计.html" class="nav-link">
  小程序架构
</a></div><div class="nav-item"><a href="/about/vue/newVue时候都做了什么.html" class="nav-link">
  vue
</a></div><div class="nav-item"><a href="/about/question/vue.html" class="nav-link">
  常见考点
</a></div><div class="nav-item"><a href="/about/nature/性能优化知识体系.html#从原理到实践-各个击破" class="nav-link">
  性能优化
</a></div> <a href="https://github.com/18722696161" target="_blank" rel="noopener noreferrer" class="repo-link">
    Github
    <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/" class="nav-link">
  首页
</a></div><div class="nav-item"><a href="/about/project/项目总结.html" class="nav-link">
  项目经历
</a></div><div class="nav-item"><a href="/about/project/微前端.html" class="nav-link">
  微前端
</a></div><div class="nav-item"><a href="/about/project/性能监控.html" class="nav-link">
  性能监控
</a></div><div class="nav-item"><a href="/about/project/小程序架构设计.html" class="nav-link">
  小程序架构
</a></div><div class="nav-item"><a href="/about/vue/newVue时候都做了什么.html" class="nav-link">
  vue
</a></div><div class="nav-item"><a href="/about/question/vue.html" class="nav-link">
  常见考点
</a></div><div class="nav-item"><a href="/about/nature/性能优化知识体系.html#从原理到实践-各个击破" class="nav-link">
  性能优化
</a></div> <a href="https://github.com/18722696161" target="_blank" rel="noopener noreferrer" class="repo-link">
    Github
    <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></nav>  <ul class="sidebar-links"><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>JS基础</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>Node</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>CSS</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>Vue2</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>Vue3</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>React</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>WebPack</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>Http</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading open"><span>性能优化</span> <span class="arrow down"></span></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/about/nature/性能优化知识体系.html" class="sidebar-link">知识体系： 从一道面试题说起</a></li><li><a href="/about/nature/webpack性能调优与Gzip原理.html" class="sidebar-link">一、webpack 性能调优与 Gzip 原理</a></li><li><a href="/about/nature/图片优化-质量与性能的博弈.html" class="sidebar-link">二、图片优化——质量与性能的博弈</a></li><li><a href="/about/nature/浏览器缓存机制介绍与缓存策略剖析.html" class="active sidebar-link">三、浏览器缓存机制介绍与缓存策略剖析</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/about/nature/浏览器缓存机制介绍与缓存策略剖析.html#http-缓存机制探秘" class="sidebar-link">HTTP 缓存机制探秘</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/about/nature/浏览器缓存机制介绍与缓存策略剖析.html#强缓存的特征" class="sidebar-link">强缓存的特征</a></li><li class="sidebar-sub-header"><a href="/about/nature/浏览器缓存机制介绍与缓存策略剖析.html#强缓存的实现-从-expires-到-cache-control" class="sidebar-link">强缓存的实现：从 expires 到 cache-control</a></li><li class="sidebar-sub-header"><a href="/about/nature/浏览器缓存机制介绍与缓存策略剖析.html#cache-control-应用分析" class="sidebar-link">Cache-Control 应用分析</a></li><li class="sidebar-sub-header"><a href="/about/nature/浏览器缓存机制介绍与缓存策略剖析.html#协商缓存-浏览器与服务器合作之下的缓存策略" class="sidebar-link">协商缓存：浏览器与服务器合作之下的缓存策略</a></li><li class="sidebar-sub-header"><a href="/about/nature/浏览器缓存机制介绍与缓存策略剖析.html#协商缓存的实现-从-last-modified-到-etag" class="sidebar-link">协商缓存的实现：从 Last-Modified 到 Etag</a></li></ul></li><li class="sidebar-sub-header"><a href="/about/nature/浏览器缓存机制介绍与缓存策略剖析.html#http-缓存决策指南" class="sidebar-link">HTTP 缓存决策指南</a></li><li class="sidebar-sub-header"><a href="/about/nature/浏览器缓存机制介绍与缓存策略剖析.html#memorycache" class="sidebar-link">MemoryCache</a></li><li class="sidebar-sub-header"><a href="/about/nature/浏览器缓存机制介绍与缓存策略剖析.html#service-worker-cache" class="sidebar-link">Service Worker Cache</a></li><li class="sidebar-sub-header"><a href="/about/nature/浏览器缓存机制介绍与缓存策略剖析.html#push-cache" class="sidebar-link">Push Cache</a></li><li class="sidebar-sub-header"><a href="/about/nature/浏览器缓存机制介绍与缓存策略剖析.html#小结" class="sidebar-link">小结</a></li></ul></li><li><a href="/about/nature/本地存储——从 Cookie 到 Web Storage、IndexDB.html" class="sidebar-link">四、本地存储——从 Cookie 到 Web Storage、IndexDB</a></li><li><a href="/about/nature/CDN 的缓存与回源机制解析.html" class="sidebar-link">五、CDN 的缓存与回源机制解析</a></li><li><a href="/about/nature/服务端渲染的探索与实践.html" class="sidebar-link">六、服务端渲染的探索与实践</a></li><li><a href="/about/nature/知己知彼——解锁浏览器背后的运行机制.html" class="sidebar-link">七、知己知彼——解锁浏览器背后的运行机制</a></li><li><a href="/about/nature/对症下药—— DOM 优化原理与基本实践.html" class="sidebar-link">八、对症下药—— DOM 优化原理与基本实践</a></li><li><a href="/about/nature/千方百计——Event Loop 与异步更新策略.html" class="sidebar-link">九、千方百计——Event Loop 与异步更新策略</a></li><li><a href="/about/nature/最后一击——回流Reflow与重绘Repaint.html" class="sidebar-link">十、最后一击——回流（Reflow）与重绘（Repaint）</a></li><li><a href="/about/nature/优化首屏体验——Lazy-Load 初探.html" class="sidebar-link">十一、优化首屏体验——Lazy-Load 初探</a></li><li><a href="/about/nature/事件的节流throttle与防抖debounce.html" class="sidebar-link">十二、事件的节流（throttle）与防抖（debounce）</a></li><li><a href="/about/nature/Performance、LightHouse 与性能 API.html" class="sidebar-link">十三、Performance、LightHouse 与性能 API</a></li></ul></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>区块链</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>算法</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>前端遇到的问题</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>日志及监控</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>chrome插件开发</span> <span class="arrow right"></span></p> <!----></section></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h1 id="三、浏览器缓存机制介绍与缓存策略剖析"><a href="#三、浏览器缓存机制介绍与缓存策略剖析" class="header-anchor">#</a> 三、浏览器缓存机制介绍与缓存策略剖析</h1> <p>缓存可以减少网络 IO 消耗，提高访问速度。浏览器缓存是一种操作简单、效果显著的前端性能优化手
段。对于这个操作的必要性，Chrome 官方给出的解释似乎更有说服力一些：
通过网络获取内容既速度缓慢又开销巨大。较大的响应需要在客户端与服务器之间进行多次往返
通信，这会延迟浏览器获得和处理内容的时间，还会增加访问者的流量费用。因此，缓存并重复
利用之前获取的资源的能力成为性能优化的一个关键方面。
很多时候，大家倾向于将浏览器缓存简单地理解为“HTTP 缓存”。但事实上，浏览器缓存机制有四个方
面，它们按照获取资源时请求的优先级依次排列如下：</p> <ol><li>Memory Cache</li> <li>Service Worker Cache</li> <li>HTTP Cache</li> <li>Push Cache
大家对 HTTP Cache（即 Cache-Control、expires 等字段控制的缓存）应该比较熟悉，如果对其它几种
缓存可能还没什么概念，我们可以先来看一张线上网站的 Network 面板截图：
<img src="/assets/img/youhua15.ef37484e.png">
我们给 size 这一栏一个特写：
<img src="/assets/img/youhua16.aed50536.png">
大家注意一下非数字——即形如“（from xxx）”这样的描述——对应的资源，这些资源就是我们通过缓
存获取到的。其中，“from memory cache”对标到 Memory Cache 类型，“from ServiceWorker”对标
到 Service Worker Cache 类型。至于 Push Cache，这个比较特殊，是 HTTP2 的新特性。
本节将会针对这四个方面各个击破。考虑到 HTTP 缓存是最主要、最具有代表性的缓存策略，也是每一
位前端工程师都应该深刻理解掌握的性能优化知识点，我们下面优先针对 HTTP 缓存机制进行剖析。</li></ol> <h2 id="http-缓存机制探秘"><a href="#http-缓存机制探秘" class="header-anchor">#</a> HTTP 缓存机制探秘</h2> <p>HTTP 缓存是我们日常开发中最为熟悉的一种缓存机制。它又分为强缓存和协商缓存。优先级较高的是
强缓存，在命中强缓存失败的情况下，才会走协商缓存。</p> <h3 id="强缓存的特征"><a href="#强缓存的特征" class="header-anchor">#</a> 强缓存的特征</h3> <p>强缓存是利用 http 头中的 Expires 和 Cache-Control 两个字段来控制的。强缓存中，当请求再次发出
时，浏览器会根据其中的 expires 和 cache-control 判断目标资源是否“命中”强缓存，若命中则直接从
缓存中获取资源，不会再与服务端发生通信。
命中强缓存的情况下，返回的 HTTP 状态码为 200 （如下图）。
<img src="/assets/img/youhua17.33ddd9fb.png"></p> <h3 id="强缓存的实现-从-expires-到-cache-control"><a href="#强缓存的实现-从-expires-到-cache-control" class="header-anchor">#</a> 强缓存的实现：从 expires 到 cache-control</h3> <p>实现强缓存，过去我们一直用 expires 。
当服务器返回响应时，在 Response Headers 中将过期时间写入 expires 字段。像这样：
<img src="/assets/img/youhua18.7408e8af.png">
我们给 expires 一个特写：</p> <div class="language- extra-class"><pre class="language-text"><code>expires: Wed, 11 Sep 2019 16:12:18 GMT
</code></pre></div><p>可以看到，expires 是一个时间戳，接下来如果我们试图再次向服务器请求资源，浏览器就会先对比本
地时间和 expires 的时间戳，如果本地时间小于 expires 设定的过期时间，那么就直接去缓存中取这个
资源。
从这样的描述中大家也不难猜测，expires 是有问题的，它最大的问题在于对“本地时间”的依赖。如果
服务端和客户端的时间设置可能不同，或者我直接手动去把客户端的时间改掉，那么 expires 将无法达
到我们的预期。
考虑到 expires 的局限性，HTTP1.1 新增了 Cache-Control 字段来完成 expires 的任务。
expires 能做的事情，Cache-Control 都能做；expires 完成不了的事情，Cache-Control 也能做。因
此，Cache-Control 可以视作是 expires 的完全替代方案。在当下的前端实践里，我们继续使用
expires 的唯一目的就是向下兼容。
现在我们给 Cache-Control 字段一个特写：</p> <div class="language- extra-class"><pre class="language-text"><code>cache-control: max-age=31536000
</code></pre></div><p>如大家所见，在 Cache-Control 中，我们通过 max-age 来控制资源的有效期。max-age 不是一个时间
戳，而是一个时间长度。在本例中，max-age 是 31536000 秒，它意味着该资源在 31536000 秒以内
都是有效的，完美地规避了时间戳带来的潜在问题。</p> <p>Cache-Control 相对于 expires 更加准确，它的优先级也更高。当 Cache-Control 与 expires 同时出
现时，我们以 Cache-Control 为准。</p> <h3 id="cache-control-应用分析"><a href="#cache-control-应用分析" class="header-anchor">#</a> Cache-Control 应用分析</h3> <p>Cache-Control 的神通，可不止于这一个小小的 max-age。如下的用法也非常常见：</p> <div class="language- extra-class"><pre class="language-text"><code>cache-control: max-age=3600, s-maxage=31536000
</code></pre></div><p>s-maxage 优先级高于 max-age，两者同时出现时，优先考虑 s-maxage。如果 s-maxage 未过期，
则向代理服务器请求其缓存内容。
这个 s-maxage 不像 max-age 一样为大家所熟知。的确，在项目不是特别大的场景下，max-age 足够
用了。但在依赖各种代理的大型架构中，我们不得不考虑代理服务器的缓存问题。s-maxage 就是用于
表示 cache 服务器上（比如 cache CDN）的缓存的有效时间的，并只对 public 缓存有效。
(10.24晚更新。感谢评论区@敖天羽的补充，此处应注意这样一个细节：s-maxage仅在代理服务器中生
效，客户端中我们只考虑max-age。)
那么什么是 public 缓存呢？说到这里，Cache-Control 中有一些适合放在一起理解的知识点，我们集中
梳理一下：</p> <h4 id="public-与-private"><a href="#public-与-private" class="header-anchor">#</a> public 与 private</h4> <p>public 与 private 是针对资源是否能够被代理服务缓存而存在的一组对立概念。
如果我们为资源设置了 public，那么它既可以被浏览器缓存，也可以被代理服务器缓存；如果我们设置
了 private，则该资源只能被浏览器缓存。private 为默认值。但多数情况下，public 并不需要我们手动
设置，比如有很多线上网站的 cache-control 是这样的：
<img src="/assets/img/youhua19.9953b090.png">
设置了 s-maxage，没设置 public，那么 CDN 还可以缓存这个资源吗？答案是肯定的。因为明确的缓
存信息（例如“max-age”）已表示响应是可以缓存的。</p> <h4 id="no-store与no-cache"><a href="#no-store与no-cache" class="header-anchor">#</a> no-store与no-cache</h4> <p>no-cache 绕开了浏览器：我们为资源设置了 no-cache 后，每一次发起请求都不会再去询问浏览器的缓
存情况，而是直接向服务端去确认该资源是否过期（即走我们下文即将讲解的协商缓存的路线）。
no-store 比较绝情，顾名思义就是不使用任何缓存策略。在 no-cache 的基础上，它连服务端的缓存确
认也绕开了，只允许你直接向服务端发送请求、并下载完整的响应。</p> <h3 id="协商缓存-浏览器与服务器合作之下的缓存策略"><a href="#协商缓存-浏览器与服务器合作之下的缓存策略" class="header-anchor">#</a> 协商缓存：浏览器与服务器合作之下的缓存策略</h3> <p>协商缓存依赖于服务端与浏览器之间的通信。
协商缓存机制下，浏览器需要向服务器去询问缓存的相关信息，进而判断是重新发起请求、下载完整的
响应，还是从本地获取缓存的资源。
如果服务端提示缓存资源未改动（Not Modified），资源会被重定向到浏览器缓存，这种情况下网络请
求对应的状态码是 304（如下图）。
<img src="/assets/img/youhua20.6429c2e8.png"></p> <h3 id="协商缓存的实现-从-last-modified-到-etag"><a href="#协商缓存的实现-从-last-modified-到-etag" class="header-anchor">#</a> 协商缓存的实现：从 Last-Modified 到 Etag</h3> <p>Last-Modified 是一个时间戳，如果我们启用了协商缓存，它会在首次请求时随着 Response Headers
返回：</p> <div class="language- extra-class"><pre class="language-text"><code>Last-Modified: Fri, 27 Oct 2017 06:35:57 GMT
</code></pre></div><p>随后我们每次请求时，会带上一个叫 If-Modified-Since 的时间戳字段，它的值正是上一次 response 返
回给它的 last-modified 值：</p> <div class="language- extra-class"><pre class="language-text"><code>If-Modified-Since: Fri, 27 Oct 2017 06:35:57 GMT
</code></pre></div><p>服务器接收到这个时间戳后，会比对该时间戳和资源在服务器上的最后修改时间是否一致，从而判断资
源是否发生了变化。如果发生了变化，就会返回一个完整的响应内容，并在 Response Headers 中添加
新的 Last-Modified 值；否则，返回如上图的 304 响应，Response Headers 不会再添加 Last-
Modified 字段。</p> <p>使用 Last-Modified 存在一些弊端，这其中最常见的就是这样两个场景：</p> <ul><li>我们编辑了文件，但文件的内容没有改变。服务端并不清楚我们是否真正改变了文件，它仍然通过
最后编辑时间进行判断。因此这个资源在再次被请求时，会被当做新资源，进而引发一次完整的响
应——不该重新请求的时候，也会重新请求。</li> <li>当我们修改文件的速度过快时（比如花了 100ms 完成了改动），由于 If-Modified-Since 只能检
查到以秒为最小计量单位的时间差，所以它是感知不到这个改动的——该重新请求的时候，反而没
有重新请求了。
这两个场景其实指向了同一个 bug——服务器并没有正确感知文件的变化。为了解决这样的问题，Etag
作为 Last-Modified 的补充出现了。
Etag 是由服务器为每个资源生成的唯一的标识字符串，这个标识字符串是基于文件内容编码的，只要文
件内容不同，它们对应的 Etag 就是不同的，反之亦然。因此 Etag 能够精准地感知文件的变化。
Etag 和 Last-Modified 类似，当首次请求时，我们会在响应头里获取到一个最初的标识符字符串，举个
🌰，它可以是这样的：</li></ul> <div class="language- extra-class"><pre class="language-text"><code>ETag: W/&quot;2a3b-1602480f459&quot;
</code></pre></div><p>那么下一次请求时，请求头里就会带上一个值相同的、名为 if-None-Match 的字符串供服务端比对了：</p> <div class="language- extra-class"><pre class="language-text"><code>If-None-Match: W/&quot;2a3b-1602480f459&quot;
</code></pre></div><p>Etag 的生成过程需要服务器额外付出开销，会影响服务端的性能，这是它的弊端。因此启用 Etag 需要
我们审时度势。正如我们刚刚所提到的——Etag 并不能替代 Last-Modified，它只能作为 Last-
Modified 的补充和强化存在。 Etag 在感知文件变化上比 Last-Modified 更加准确，优先级也更高。
当 Etag 和 Last-Modified 同时存在时，以 Etag 为准。</p> <h2 id="http-缓存决策指南"><a href="#http-缓存决策指南" class="header-anchor">#</a> HTTP 缓存决策指南</h2> <p>行文至此，当代 HTTP 缓存技术用到的知识点，我们已经从头到尾挖掘了一遍了。那么在面对一个具体
的缓存需求时，我们到底该怎么决策呢？
走到决策建议这一步，我本来想给大家重新画一个流程图。但是画来画去终究不如 Chrome 官方给出的
这张清晰、权威：
<img src="/assets/img/youhua21.2da9764d.png">
我们现在一起解读一下这张流程图：
当我们的资源内容不可复用时，直接为 Cache-Control 设置 no-store，拒绝一切形式的缓存；否则考虑
是否每次都需要向服务器进行缓存有效确认，如果需要，那么设 Cache-Control 的值为 no-cache；否
则考虑该资源是否可以被代理服务器缓存，根据其结果决定是设置为 private 还是 public；然后考虑该
资源的过期时间，设置对应的 max-age 和 s-maxage 值；最后，配置协商缓存需要用到的 Etag、Last-
Modified 等参数。
我个人非常推崇这张流程图给出的决策建议，也强烈推荐大家在理解以上知识点的基础上，将这张图保
存下来、在日常开发中用用看，它的可行度非常高。
OK，走到这里，本节最大的一座山已经被大家翻过去了。接下来的内容会相对比较轻松，大家放松心
情，我们继续前行！</p> <h2 id="memorycache"><a href="#memorycache" class="header-anchor">#</a> MemoryCache</h2> <p>MemoryCache，是指存在内存中的缓存。从优先级上来说，它是浏览器最先尝试去命中的一种缓存。
从效率上来说，它是响应速度最快的一种缓存。
内存缓存是快的，也是“短命”的。它和渲染进程“生死相依”，当进程结束后，也就是 tab 关闭以后，内
存里的数据也将不复存在。
那么哪些文件会被放入内存呢？
事实上，这个划分规则，一直以来是没有定论的。不过想想也可以理解，内存是有限的，很多时候需要
先考虑即时呈现的内存余量，再根据具体的情况决定分配给内存和磁盘的资源量的比重——资源存放的
位置具有一定的随机性。
虽然划分规则没有定论，但根据日常开发中观察的结果，包括我们开篇给大家展示的 Network 截图，
我们至少可以总结出这样的规律：资源存不存内存，浏览器秉承的是“节约原则”。我们发现，Base64
格式的图片，几乎永远可以被塞进 memory cache，这可以视作浏览器为节省渲染开销的“自保行为”；
此外，体积不大的 JS、CSS 文件，也有较大地被写入内存的几率——相比之下，较大的 JS、CSS 文件就
没有这个待遇了，内存资源是有限的，它们往往被直接甩进磁盘。</p> <h2 id="service-worker-cache"><a href="#service-worker-cache" class="header-anchor">#</a> Service Worker Cache</h2> <p>Service Worker 是一种独立于主线程之外的 Javascript 线程。它脱离于浏览器窗体，因此无法直接访问
DOM。这样独立的个性使得 Service Worker 的“个人行为”无法干扰页面的性能，这个“幕后工作者”可以
帮我们实现离线缓存、消息推送和网络代理等功能。我们借助 Service worker 实现的离线缓存就称为
Service Worker Cache。
Service Worker 的生命周期包括 install、active、working 三个阶段。一旦 Service Worker 被
install，它将始终存在，只会在 active 与 working 之间切换，除非我们主动终止它。这是它可以用来实
现离线存储的重要先决条件。
下面我们就通过实战的方式，一起见识一下 Service Worker 如何为我们实现离线缓存（注意看注
释）： 我们首先在入口文件中插入这样一段 JS 代码，用以判断和引入 Service Worker：</p> <div class="language- extra-class"><pre class="language-text"><code>window.navigator.serviceWorker.register('/test.js')
  .then(function () {
    console.log('注册成功')
})
  .catch(err =&gt; {
    console.error(&quot;注册失败&quot;)
})
</code></pre></div><p>在 test.js 中，我们进行缓存的处理。假设我们需要缓存的文件分别是 test.html,test.css 和 test.js：</p> <div class="language- extra-class"><pre class="language-text"><code>// Service Worker会监听 install事件，我们在其对应的回调里可以实现初始化的逻辑
self.addEventListener('install', event =&gt; {
event.waitUntil(
// 考虑到缓存也需要更新，open内传入的参数为缓存的版本号
caches.open('test-v1').then(cache =&gt; {
return cache.addAll([
// 此处传入指定的需缓存的文件名
'/test.html',
'/test.css',
'/test.js'
])
})
)
})
// Service Worker会监听所有的网络请求，网络请求的产生触发的是fetch事件，我们可以在其对应的监
听函数中实现对请求的拦截，进而判断是否有对应到该请求的缓存，实现从Service Worker中取到缓存的目
的
self.addEventListener('fetch', event =&gt; {
  event.respondWith(
    // 尝试匹配该请求对应的缓存值
    caches.match(event.request).then(res =&gt; {
      // 如果匹配到了，调用Server Worker缓存
      if (res) {
        return res;
      }
      // 如果没匹配到，向服务端发起这个资源请求
      return fetch(event.request).then(response =&gt; {
        if (!response || response.status !== 200) {
          return response;
        }
        // 请求成功的话，将请求缓存起来。
        caches.open('test-v1').then(function (cache) {
          cache.put(event.request, response);
        });
        return response.clone();
      });
    })
  );
});
</code></pre></div><p>PS：大家注意 Server Worker 对协议是有要求的，必须以 https 协议为前提。</p> <h2 id="push-cache"><a href="#push-cache" class="header-anchor">#</a> Push Cache</h2> <p>预告：本小节定位为基础科普向，对 Push Cache 有深入挖掘兴趣的同学，强烈推荐拓展阅读
Chrome 工程师 Jake Archibald 的这篇 HTTP/2 push is tougher than I thought。</p> <ul><li>Push Cache 是指 HTTP2 在 server push 阶段存在的缓存。这块的知识比较新，应用也还处于萌芽阶
段，我找了好几个网站也没找到一个合适的案例来给大家做具体的介绍。但应用范围有限不代表不重要
——HTTP2 是趋势、是未来。在它还未被推而广之的此时此刻，我仍希望大家能对 Push Cache 的关键
特性有所了解：</li> <li>Push Cache 是缓存的最后一道防线。浏览器只有在 Memory Cache、HTTP Cache 和 Service
Worker Cache 均未命中的情况下才会去询问 Push Cache。
Push Cache 是一种存在于会话阶段的缓存，当 session 终止时，缓存也随之释放。</li> <li>不同的页面只要共享了同一个 HTTP2 连接，那么它们就可以共享同一个 Push Cache。</li></ul> <h2 id="小结"><a href="#小结" class="header-anchor">#</a> 小结</h2> <p>小建议！很多同学在学习缓存这块知识的时候可能多少会有这样的感觉：对浏览器缓存，只能描述个大
致，却说不上深层原理；好不容易记住了每个字段怎么用，过几天又给忘了。这是因为缓存部分的知
识，具有“细碎、迭代快”的特点。对于这样的知识，我们应该尝试先划分出层次和重点，归纳出完整的
体系，然后针对每个知识点去各个击破。
终于结束了对缓存世界的探索，不知道大家有没有一种意犹未尽的感觉。开篇我们谈过，缓存非常重
要，它几乎是我们性能优化的首选方案。
但页面的数据存储方案除了缓存，还有本地存储。在下一节中，我们就将围绕本地存储展开探索。</p></div> <footer class="page-edit"><div class="edit-link"><a href="https://github.com/18722696161/edit/master/docs/about/nature/浏览器缓存机制介绍与缓存策略剖析.md" target="_blank" rel="noopener noreferrer">在github上编辑此页</a> <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></div> <!----></footer> <div class="page-nav"><p class="inner"><span class="prev">
      ←
      <a href="/about/nature/图片优化-质量与性能的博弈.html" class="prev">
        二、图片优化——质量与性能的博弈
      </a></span> <span class="next"><a href="/about/nature/本地存储——从 Cookie 到 Web Storage、IndexDB.html">
        四、本地存储——从 Cookie 到 Web Storage、IndexDB
      </a>
      →
    </span></p></div> </main></div><div class="global-ui"><!----><!----></div></div>
    <script src="/assets/js/app.6365c275.js" defer></script><script src="/assets/js/2.f728fa66.js" defer></script><script src="/assets/js/6.a279f8e6.js" defer></script><script src="/assets/js/13.35cba3fc.js" defer></script>
  </body>
</html>
